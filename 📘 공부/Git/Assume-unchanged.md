#git #깃 

오늘 특정 파일을 stage에 올리려고 하는데 아무리 변경해도 추적이 안되길래 `.gitignore` 파일에 등록되어있나보다라고 생각했다. (충분히 그럴만한 파일들이긴 해서)

하지만 해당 파일에 등록되어있지 않았고, 한동안 이유를 찾다가 `assume-unchanged` 처리가 되어있는 것을 알았고,  `No assume unchanged` 기능을 통해 해제하여 해결했다.

이왕 알게 된 기능인데 정리하여 나중에 활용해보려고 한다.


### Git assume 옵션

✔ 필요한 이유 
+ 항상 커밋할 필요없지만 추적 되는 파일들
+ 대용량 로그 파일, 캐시 산출물
+ 환경 별로 달라지는 설정 파일 (.env, config.json 등)

👉 매번 `git status`에 잡히면 귀찮고 diff 검사를 수행하기 때문에 성능적으로 부담도 있다.
두 가지 옵션을 통해 개선할 수 있다.
#### 1. assume-unchanged

```bash
git update-index --assume-unchanged <file> #설정
git update-index --no-assume-unchanged <file> #해제
```

+ 해당 파일은 바뀌지 않을거라고 알려주기
+ 로컬에서 파일을 수정해도 Git이 변경 감지를 하지 않는다.
+ 사용처
	+ 대형 로그, 빌드 결과물 등 커밋이 필요없는 파일 등

❗ 주의점 
+ 파일이 실제로 바뀌어도 Git이 추적하지 않기 때문에, 협업 환경에서는 충돌, 동기화의 위험이 있다.
+ 환경 파일에는 부적합하다. (환경 파일은 얼마든지 수정될 가능성이 있는 파일이기 때문이다.)

#### 2. skip-worktree


```bash
git update-index --skip-worktree <file>
git update-index --no-skip-worktree <file>
```

+ 해당 파일은 로컬에서 다르게 써도 된다.
+ 로컬 변경은 무시되지만, 원격에서 파일이 바뀌면 여전히 충돌 가능하다.
+ 사용처
	+ `.env`, `application.yml` 같은 환경 의존성 파일
	+ 저장소에 템플릿만 두고 (`.env.example`) , 로컬 파일은 각자 다르게 사용할 수 있다.


### 🔍 결론

해당 옵션에 대해서 찾다보니 협업을 하는 환경에서는 잘 쓰지 않을 기능인 것 같다는 생각이 들었다. 이유는 다음과 같다.

#### 1. 리스크

+ 파일이 실제로 변경되었는데 감지하지 않아 실수를 유발할 수 있을 것 같다는 생각이 들었다.
+ 충돌, 빌드 실패 등 실수로 인해 다양한 문제를 야기할 수 있겠다는 생각이 들었다.

#### 2. 더 좋은 대안이 존재

+ `.gitignore`을 통해 애초에 커밋 대상에서 제외하는 방식이 더 나아보인다.

#### 3. 유지보수의 어려움

+ 내가 걸어놓고 찾는데도 아주 오래 걸렸는데, 그 수많은 파일에서 찾는다고 생각하면 머리가 아프다.
+ `git ls-files -v` 해당 명령어로 찾을 수 있다고는 한다.

```bash
# 출력 예시

$ git ls-files -v
H .gitignore
H README.md
h logs/debug.log
S config/local.env
H src/main/App.java
```

| 기호    | 의미               | 설명                                    |
| ----- | ---------------- | ------------------------------------- |
| **H** | normal           | 기본 상태 (Tracked, 특별한 플래그 없음)           |
| **h** | assume-unchanged | Git이 “이 파일은 바뀌지 않는다”고 가정 (변경 무시)      |
| **S** | skip-worktree    | Git이 로컬 변경을 무시 (환경 의존성 파일 관리 시 주로 사용) |

해당 옵션은 그냥 알아두기만 하고 혹시나 오늘처럼 제대로 추적이 안될 때 의심해볼 수 있을 것 같다.

